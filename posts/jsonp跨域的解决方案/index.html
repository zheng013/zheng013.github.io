<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>郑李建的个人博客  | JSONP跨域的解决方案</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.59.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="JSONP跨域的解决方案" />
<meta property="og:description" content=" 同源策略（浏览器出于安全的考虑，只允许与同域下的接口交互）  同协议：如都是http或https 同域名：如都是jirengu.com/a或jirengu.com/b 同端口：如都是80端口 只有以上三个全部相同才能说是同源，否则都需要考虑跨域的问题。  JSONP（JSON with padding）  JSONP就是通过script标签加载数据的方式去获取数据当做JS代码来执行。 需提前在页面上声明一个函数，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上包裹这个函数名，发送给前端。也就是，JSONP需要对应的接口的后端配合才能实现。  应用代码 function jsonp(setting) { setting.data=setting.data||{} setting.key=setting.key||&#39;callback&#39; setting.callback=setting.callback||function(){} setting.data[setting.key]=&#39;__onGetData__&#39; window.__onGetData__=function(data){ setting.callback(data) } const script=document.createElement(&#39;script&#39;) const query=[] for(var key in setting.data){ query.push(key&#43;&#39;=&#39;&#43;encodeURIComponent(setting.data)) } script.src=setting.url&#43;&#39;?&#39;&#43;query.join(&#39;&amp;&#39;) document.head.appendChild(script) document.head.removeChild(script) } //实现一个jsonp的简单封装 jsonp({ url:&#39;http://photo.sina.cn/aj/index&#39;, key:&#39;jsoncallback&#39;, data:{ page:2, cate:&#39;recommend&#39; }, callback:function(ret){ console.log(ret) } })  后续有相关内容会继续补充。。。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zheng-en.xyz/posts/jsonp%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" />
<meta property="article:published_time" content="2020-03-05T19:33:27+08:00" />
<meta property="article:modified_time" content="2020-03-05T19:33:27+08:00" />
<meta itemprop="name" content="JSONP跨域的解决方案">
<meta itemprop="description" content=" 同源策略（浏览器出于安全的考虑，只允许与同域下的接口交互）  同协议：如都是http或https 同域名：如都是jirengu.com/a或jirengu.com/b 同端口：如都是80端口 只有以上三个全部相同才能说是同源，否则都需要考虑跨域的问题。  JSONP（JSON with padding）  JSONP就是通过script标签加载数据的方式去获取数据当做JS代码来执行。 需提前在页面上声明一个函数，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上包裹这个函数名，发送给前端。也就是，JSONP需要对应的接口的后端配合才能实现。  应用代码 function jsonp(setting) { setting.data=setting.data||{} setting.key=setting.key||&#39;callback&#39; setting.callback=setting.callback||function(){} setting.data[setting.key]=&#39;__onGetData__&#39; window.__onGetData__=function(data){ setting.callback(data) } const script=document.createElement(&#39;script&#39;) const query=[] for(var key in setting.data){ query.push(key&#43;&#39;=&#39;&#43;encodeURIComponent(setting.data)) } script.src=setting.url&#43;&#39;?&#39;&#43;query.join(&#39;&amp;&#39;) document.head.appendChild(script) document.head.removeChild(script) } //实现一个jsonp的简单封装 jsonp({ url:&#39;http://photo.sina.cn/aj/index&#39;, key:&#39;jsoncallback&#39;, data:{ page:2, cate:&#39;recommend&#39; }, callback:function(ret){ console.log(ret) } })  后续有相关内容会继续补充。。。 ">


<meta itemprop="datePublished" content="2020-03-05T19:33:27&#43;08:00" />
<meta itemprop="dateModified" content="2020-03-05T19:33:27&#43;08:00" />
<meta itemprop="wordCount" content="48">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JSONP跨域的解决方案"/>
<meta name="twitter:description" content=" 同源策略（浏览器出于安全的考虑，只允许与同域下的接口交互）  同协议：如都是http或https 同域名：如都是jirengu.com/a或jirengu.com/b 同端口：如都是80端口 只有以上三个全部相同才能说是同源，否则都需要考虑跨域的问题。  JSONP（JSON with padding）  JSONP就是通过script标签加载数据的方式去获取数据当做JS代码来执行。 需提前在页面上声明一个函数，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上包裹这个函数名，发送给前端。也就是，JSONP需要对应的接口的后端配合才能实现。  应用代码 function jsonp(setting) { setting.data=setting.data||{} setting.key=setting.key||&#39;callback&#39; setting.callback=setting.callback||function(){} setting.data[setting.key]=&#39;__onGetData__&#39; window.__onGetData__=function(data){ setting.callback(data) } const script=document.createElement(&#39;script&#39;) const query=[] for(var key in setting.data){ query.push(key&#43;&#39;=&#39;&#43;encodeURIComponent(setting.data)) } script.src=setting.url&#43;&#39;?&#39;&#43;query.join(&#39;&amp;&#39;) document.head.appendChild(script) document.head.removeChild(script) } //实现一个jsonp的简单封装 jsonp({ url:&#39;http://photo.sina.cn/aj/index&#39;, key:&#39;jsoncallback&#39;, data:{ page:2, cate:&#39;recommend&#39; }, callback:function(ret){ console.log(ret) } })  后续有相关内容会继续补充。。。 "/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://zheng-en.xyz/" class="f3 fw2 hover-white no-underline white-90 dib">
      郑李建的个人博客
    </a>
    <div class="flex-l items-center">
      

      
      











    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">JSONP跨域的解决方案</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2020-03-05T19:33:27&#43;08:00">March 5, 2020</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h2 id="同源策略-浏览器出于安全的考虑-只允许与同域下的接口交互">同源策略（浏览器出于安全的考虑，只允许与同域下的接口交互）</h2>

<ul>
<li>同协议：如都是http或https</li>
<li>同域名：如都是jirengu.com/a或jirengu.com/b</li>
<li>同端口：如都是80端口</li>
<li>只有以上三个全部相同才能说是同源，否则都需要考虑跨域的问题。</li>
</ul>

<h2 id="jsonp-json-with-padding">JSONP（JSON with padding）</h2>

<ul>
<li>JSONP就是通过script标签加载数据的方式去获取数据当做JS代码来执行。</li>
<li>需提前在页面上声明一个函数，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上包裹这个函数名，发送给前端。也就是，JSONP需要对应的接口的后端配合才能实现。</li>
</ul>

<h2 id="应用代码">应用代码</h2>

<pre><code class="language-(javascript)">function jsonp(setting)
{
setting.data=setting.data||{}
setting.key=setting.key||'callback'
setting.callback=setting.callback||function(){}
setting.data[setting.key]='__onGetData__'
window.__onGetData__=function(data){
    setting.callback(data)
}

const script=document.createElement('script')
const query=[]
for(var key in setting.data){
query.push(key+'='+encodeURIComponent(setting.data))
}
script.src=setting.url+'?'+query.join('&amp;')
document.head.appendChild(script)
document.head.removeChild(script)
}
//实现一个jsonp的简单封装

jsonp({
    url:'http://photo.sina.cn/aj/index',
    key:'jsoncallback',
    data:{
        page:2,
        cate:'recommend'
    },
    callback:function(ret){
        console.log(ret)
    }
})
</code></pre>

<h3 id="后续有相关内容会继续补充">后续有相关内容会继续补充。。。</h3>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://zheng-en.xyz/" >
    &copy; 2020 郑李建的个人博客
  </a>
    <div>










</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>

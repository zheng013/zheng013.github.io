<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>郑李建的个人博客 </title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.59.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
      <link href="/posts/index.xml" rel="alternate" type="application/rss+xml" title="郑李建的个人博客" />
      <link href="/posts/index.xml" rel="feed" type="application/rss+xml" title="郑李建的个人博客" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zheng-en.xyz/posts/" />

<meta property="og:updated_time" content="2020-01-09T22:08:05+08:00" />
<meta itemprop="name" content="Posts">
<meta itemprop="description" content="">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://zheng-en.xyz/" class="f3 fw2 hover-white no-underline white-90 dib">
      郑李建的个人博客
    </a>
    <div class="flex-l items-center">
      

      
      











    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://zheng-en.xyz/posts/%E5%AF%B9%E4%BA%8Evue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9C%B0%E7%90%86%E8%A7%A3/" class="link black dim">
        对于Vue数据响应式地理解
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Vue的数据响应式的理解 我对数据响应式的理解  数据响应式，简单来说就是数据驱动。当数据发生改变时，vue会自动的去更新视图。 个人认为视图其实就是对数据的反应，我们最应该重视的如何去处理数据的变化。  基本原理  通过Object.defineProperty()方法设置了setter/getter属性完成了对data的特殊处理。 我们由了代理和监听的思想，监听就是修改data的过程，代理是在被修改过的原始data上创建的。这样，彼此的连接才不会断开。  vue的实现  图例  Vue的响应式，核心机制是观察者模式。
 数据是被观察的一方，发生改变时，通知所有的观察者，这样观察者可以做出响应，比如，重新渲染然后更新视图。
 我们把依赖数据的观察者称为 watcher
 Vue通过在data和watcher间创建一个 dep对象，来记录这种依赖关系。
 简单来说，我们需要对传入vue的任何data数据有所有控制，包括它的来源，变化，依赖等等。vue需要实时知道你的数据信息，以方便更新视图。
 至于vue中间具体实现的代码，我还需要继续研究和细品，但只要明白其中的原理和方法，就可以更快更好的去理解它。
  研究思路和方法永远比知识更重要，多实践，多思考，然后去实现他。加油ヾ(◍°∇°◍)ﾉﾞ 谢谢观看！！！
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://zheng-en.xyz/posts/%E6%B5%85%E6%9E%90vue%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/" class="link black dim">
        浅析Vue两个版本的区别
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      浅析Vue两个版本的区别 官方文档的解释 方方老师的总结 两个版本对应的文件名  完整版包含运行时和编译器。简单来说，只要文件名中不包含runtime的都是完整版，否则为运行时版的。 完整版和运行时版都加上min就表示是在生产环境下的，给用户使用的版本，减少了注释等等。  template 和 render 怎么用  由于运行时版的vue缺少了编译器，我们就不能在template下写html文件。此时就必须通过render提供的一个h函数，编写h函数下的代码实现转换。但如果我们将html文件写在*.vue文件下，然后使用h函数去render其中的内容，此时vue会通过内部的vue-loader实现编译器的效果，所有的脏活累活由其实现。 完整版拥有更多的功能，我们可以在template里直接写我们的模板代码，由编译器自动进行转换。 因为运行时版本相比完整版体积要小大约 30%，所以应该尽可能使用这个版本。如果你仍然希望使用完整版，则需要在打包工具里配置一个别名
module.exports = { // ... resolve: { alias: { 'vue$': 'vue/dist/vue.esm.js' // 用 webpack 1 时需用 'vue/dist/vue.common.js' } } } // webpack4中可使用 mode: 'production'  要尽量使用运行时版，以减少代码的体积，最重要的是提升用户的体验。
  谢谢观看 😁😁😁
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://zheng-en.xyz/posts/%E6%B5%85%E6%9E%90mvc/" class="link black dim">
        浅析MVC
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
       浅析MVC MVC 三个对象分别做什么  M：模型model用于封装与应用程序的业务逻辑以及对数据的处理方法，会有一个或多个视图监听此模型。一旦模型的数据发生变化，模型将会去通知有关视图更新。 V：视图view是它在屏幕上的表示，描绘当前model的状态。当模型的数据发生变化，视图也会相应地得到刷新自己的机会。 C：控制器controller定义用户界面对用户输入的响应方式，起到不同层面间的组织作用，用于控制应用程序的流程，它处理用户的行为和数据model上的改变。  MVC包括这三类对象，我们将他们分离以提高灵活性和复用性。  伪代码   EventBus有哪些API,是做什么用的。  eventBus主要用于各个模块间的通信，简化应用组件间的通信；解耦事件的发送者和接收者。 监听：eventBus.on(eventName,fn) 绑定：eventBUs.trigger(eventName,data) 解除：eventBus.off(eventName,fn) 伪代码  表驱动编程的理解  表格驱动的意义在于：逻辑和数据分离 表驱动法就是一种编程模式，从表里面查找信息而不使用逻辑语句。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。对简单的情况而言，使用逻辑语句更为容易和直白。但随着逻辑链的越来越复杂，查表法也就更能体现出它的优势。 提高了程序的可读性。一个消息如何处理，只要看一下驱动表就知道，非常明显。 减少了重复代码。将公共的代码逻辑抽取出来进行处理。 可扩展性。方便修改，程序有了个明显的主干。 降低了复杂度。通过把程序逻辑的复杂度转移到人类更容易处理的数据中来，从而达到控制复杂度的目标。  对于模块化的理解  何为模块化，模块化开发就是封装细节，提供使用接口，彼此之间互不影响，每个模块都是实现某一特定的功能。模块化开发的基础就是函数。 将一个程序实现在代码上的模块划分，将相同作用的模块内容结合到一起组成模块，需要的时候调用这个接口即可。实现的代码的可复用性，便于代码的维护，提高我们的工作效率。  CommonJS(参考)  模块化的目的在于营造安全封闭的作用域、且具有易于引用接口，按我的理解可分为模块定义、模块引入两部分。 在模块中存在一个module对象，它代表着模块本身，将需要导出的api挂载于其中地exports属性上就可以定义导出的接口，CommonJS规范中存在require（）方法，用于接收标识模块，引入到某个模块到当前的上下文中。
 模块化涉及的知识需要深入的应用才能真正的去理解其中的奥妙，我们现在主要是先能够了解MVC的基础，,以后学习其他框架一样要用到MVC的知识,MVC的M一样会用到ajax,MVC的V一样会用到DOM,MVC的C一样会用到数据结构,算法以及面向对象的知识。
 以我的理解，将项目模块化，分为三个部分：模型，视图和控制器三个部分。模型是应用对象，没有用户界面。视图表示它在屏幕上的显示，代表流向用户的数据。控制器定义用户界面对用户输入的响应方式，负责把用户的动作转成针对Model的操作。Model通过更新View的数据来反映数据的变化。
  感觉自己现在有点点感觉了，但还是要不断的练习，不断的去看和理解。加油！加油！
谢谢观看😁😁😁 
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://zheng-en.xyz/posts/jquery%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" class="link black dim">
        jQuery的设计思想
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      jQuery如何获取元素 jQuery的基本设计思想和主要用法，就是选择某个网页元素，然后对其进行某种操作。  CSS选择器
$(document) //选择整个文档对象 $('#myId') //选择ID为myId的网页元素 $('div.myClass') // 选择class为myClass的div元素 $('input[name=first]') // 选择name属性等于first的input元素  jQuery的特有表达式
$('a:first') //选择网页中第一个a元素 $('tr:odd') //选择表格的奇数行 $('#myForm :input') // 选择表单中的input元素 $('div:visible') //选择可见的div元素 | $('div:gt(2)') // 选择所有的div元素，除了前三个 | | | | ----------------------------------------------- | --- | | | | $('div:animated') // 选择当前处于动画状态的div元素   jQuery的链式操作是怎样的  jQuery设计思想之三，就是最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来。 这是jQuery最令人称道、最方便的特点。它的原理在于每一步的jQuery操作，返回的都是一个jQuery对象，所以不同操作可以连在一起。 例
$('div').find('h3').eq(2).html('Hello')  分解之后
$('div') //找到div元素 .find('h3') //选择其中的h3元素 .eq(2) //选择第3个h3元素 .html('Hello'); //将它的内容改为Hello  jQuery还提供了.end()方法，使得结果集可以后退一步
$('div') .find('h3') .eq(2) .html('Hello') .end() //退回到选中所有的h3元素的那一步 .
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://zheng-en.xyz/posts/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%E6%B5%85%E6%9E%90/" class="link black dim">
        Js函数的执行时机浅析
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JS函数的执行时机浅析  首先来看一下下面这段代码
let i = 0 for(i = 0; i&lt;6; i++){ setTimeout(()=&gt;{ console.log(i) },0) }  执行之后我们会发现打印出6个6，这是为什么呢？我自己搜索了一些资料，但是理解的也不是很深，因为涉及到作用与、闭包和事件循环的知识（但自己能想明白）。也是说：for循环时setTimeout()不是立即执行的，它们的回调被push到了宏任务队列当中，而在执行任务队列里的回调函数时，变量i早已变成了6。把他当做调用栈，但for执行完后，在进行回调函数执行。那其中原理就有点清晰了，我们只需要在回调函数push到队列的时候创建一个作用域的变量，他执行的时候也就会按照当时的情况去找变量，也就是很简单，就是需要给循环中的setTimeout()创建一个闭包作用域，让它执行的时候找到的变量i是正确的。 那如何让上面代码打印 0、1、2、3、4、5
  利用let关键字 for(let i = 0;i&lt;6;i++) { setTimeout(()=&gt;{ console.log(i); }, 0); }  利用setTimeout第三个参数,把每次循环的值传给他 let i = 0 for(i = 0; i&lt;6; i++){ setTimeout(()=&gt;{ console.log(i) },0,i) }  把setTimeout用一个方法单独出来形成闭包 let loop=function(i){ setTimeout(()=&gt; { console.log(i); },0 ); }; for (let i = 0;i &lt;6; i++) { loop(i) }  引入IIFE(立即执行函数相关，作用域) for(var i = 0;i&lt;6;i ++) { (function(i){ setTimeout(() =&gt; { console.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://zheng-en.xyz/posts/js%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" class="link black dim">
        JS对象的基本用法
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JS对象的基本用法 声明对象的两种语法 let obj = { 'name' : 'paul' , 'age' : '22' } //简单通用流行的写法 let obj = new Object({ 'name':'George' , 'age': '32' }) //标准官方的写法  如何删除对象的属性 delete obj['name'] //推荐新手常用的删除的方法 delete obj.name //熟悉了解之后可用  如何查看对象的属性 Object.keys(obj) // 查看对象的所有属性（包括隐藏属性） console.dir（obj）//查看打印出对象的所有属性（包括隐藏属性） obj.hasOwnProperty('name') //判断该属性是否为自身的属性 obj.name obj['name'] //查看某个对象的具体的属性 Object.values(obj) //查看对象的所有属性值 Object.entries（obj） //查看对象所有属性和属性值  如何修改或增加对象的属性（写属性）  直接赋值
let obj = { name: 'frank'} //name是字符串 obj.name='jack' //name是字符串 obj['name']='paul' obj[name] = 'frank' // 错误，因为name变量值不确定 obj['na'+'me']='frank' let key ='name',obj[key]='frank' let key ='name',obj.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://zheng-en.xyz/posts/js%E8%AF%AD%E6%B3%95/" class="link black dim">
        JS语法
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JS的基本语法 什么是表达式和语句  表达式是为了得到返回值（表达式的值是函数本身，表达式的值为函数的返回值，但这里的值不包括undefined） 语句是为了完成某种任务而进行的操作 表达式和语句的区别在于：语句是为了进行某种操作，一般情况下不需要返回值，而表达式都是为了得到返回值，一定会返回一个值。
var a = 1+3;  这就是一个语句，而1+3是一个表达式
  标识符的规则（不符合规则的就是非法标识符，系统就会报错）  标识符（identifier）：指的是用来识别各种值的合法名称 最常见的标识符就是变量名，以及后面要提到的函数名。 JS语言中对大小写敏感，故a和A是两个不同的标识符。 第一个字符，可以是任意Unicode的字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个以及后面的字符，除了第一个字符提到的之外，还可以是数字（0到9） 不合规则的标识符
2f //第一个字符不能是数字 23 //同上 **** //标识符不能含有*号 a+b //表示标识符不能含有加号 -f //标识符不能含有减号或连词线  中文是合法的标识符，也可做变量名。
  if else 语句  if(表达式){语句一}else{语句二} （一般{}不建议省略）
if(m===3){ //布尔值为ture，执行该代码块语句 } else{ //布尔值为false，执行该代码块语句 }  对同一个变量进行多次判断时，多个if&hellip;else语句可以连写在一起。
if(m===0){ //.... }else if(m===1){ //.... }else if(m===2){ //... }else { //... }  else代码块总是与离自己最近的那个if语句配对
var m = 1; var n = 2 ; if(m!
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://zheng-en.xyz/posts/%E5%86%85%E5%AD%98%E5%9B%BE%E5%92%8Cjs%E4%B8%96%E7%95%8C/" class="link black dim">
        内存图和JS世界
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      内存图与JS世界 JS引擎（V8）  JS是单线程 编译：将JS代码翻译成机器能执行的字节码或机器码 优化：改写代码，使其更为高效 执行：执行上面的字节码或机器码 垃圾回收：把JS用完的内存回收，方便之后再次使用 JS代码在内存里运行  内存图 * stack区中的数据按顺序存放 * Heap区中的数据随机存放 * 数据分为两种：对象和非对象 * 非对象一般存放于stack区 * 对象存在Heap区（数据、函数也是对象）
JS世界 * 对象的共有属性就是原型 * 每一个对象都有一个隐藏属性，指向原型（函数、数组也是一个对象）
课后作业 JS的其他相关的基础知识都总结在笔记本上&mdash;&mdash; 以后用到JS语言写代码，都会将心得和想法持续更新，这样知识才会记得更牢💪💪💪
谢谢观看🤭🤭🤭 加油&mdash;&mdash;&mdash;&ndash;
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://zheng-en.xyz/posts/%E6%B5%85%E8%B0%88javascript/" class="link black dim">
        浅谈JavaScript
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      浅谈JavaScript 早期  94年，网景公司发布了当时世界比较成熟的一个网站，但其只能用来浏览，不具备与访问者互动的能力。 因此急需一种网页脚本语言，可以使得浏览器可以互动。 两个方向：一个是利用现有的语言资源（python、TCL等）推广简单，另一个是自己开发一个完全适应的全新语言。 当时网景和sun公司联合推进了这项语言的诞生。 布莱登在依据公司要求未来的网页脚本语言需看上去与Java有联系或相似，但比其简单的要求。 仅仅在十天后布莱登就将其原型设计出来了，并在浏览器上大获成功。 JavaScript语言实际上是两种语言风格的混合产物（简化的函数式编程+简化的面向对象编程）  发展  微软公司在JavaScript推出不久后，也推出了JScript。 JScript也是一种JavaScript实现，这两个JavaScript语言版本在浏览器端共存意味着语言标准化的缺失。 96年，网景公司正式向ECMA提交语言标准。 97年，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262。JavaScript成为了ECMAScript最著名的实现之一。  现状  随着chrome浏览器的发展壮大，ie的衰落，JavaScript得以快速发展，前端技术也越来越多。 JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。 由于设计时间的仓促等相关原因，JavaScript的语言设计存在很多的缺陷和严谨，正是因为这样才造就他的灵活性。 Javascript目前是网页编程的唯一语言，只要互联网继续发展，它就必然一起发展。 node.js使得Javascript可以用于后端的服务器编程。 coffeeScript使你可以用python和ruby的语法，撰写Javascript。 要发布新版本的语言标准，就可以弥补这些设计缺陷。如ES6等后续最新的版本 虽然标准的发布和标准的实现是两回事，但是JavaScript一定会日益强壮。  JavaScript的语言缺陷和严谨性只有自己使用了才知道，世界上哪有完美的东西。但他现在就是最适合网页编程的语言，所以从另一个角度说他也是最好的。 编程语言的坑只有实际通过项目编写才能遇到，我之后会将他们归类总结，以便更高效的编写。
加油！ 已经开始学习一门语言了，要多下功夫把他学会了。 加油 加油💪💪💪
谢谢观看🏀😄🏀😄🏀😄
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://zheng-en.xyz/posts/%E6%B5%85%E6%9E%90url/" class="link black dim">
        浅析URL
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      浅析URL URL 包含哪几部分（统一资源定位符）  URL=HTTP（协议）+域名或IP+端口号+路径+查询字符串+锚点 HTTP：HyperText Transfer Protocol 超文本传输协议 域名就是IP的别称，便于用户快速访问你得网站 端口号：一台机器提供的很多服务对应着不同的端口号（默认80提供HTTP服务 默认443提供HTTPS的服务） 路径：根据提供的路径不同可以请求访问不同的页面 查询字符串：根据查询字符串的不同可以访问同一个页面下的不同内容 锚点：根据不同的#锚点可以访问统一页面的不同位置  DNS 的作用是什么  将域名与对应的IP对映起来 方便用能通过域名直接的去访问到IP  nslookup命令如何使用  nslookup baidu.com(域名) 可以查找到域名所对应的所有服务器IP地址  IP的作用是什么  可以定位到一台设备 可以封装的数据报文，以便跟其他的设备进行交流 一个域名可以对应多个IP地址（均衡负载） 一个IP地址也可以对应不同的域名（开发者为了省钱）  ping 命令怎么用  ping baidu.com 可以得到域名所在地区对应的一台服务器的IP地址 便于测试本机与服务器的联通性，较为精确。  域名是什么  可以是自己申请的由字符串构成的，也是IP地址的代称 com是顶级域名 xxx.com是二级域名（俗称一级域名） www.xxx.com是三级域名（俗称二级域名） 他们之间为父子关系 有时候www.xxx.com 和 xxx.com可能不是同一个域名，访问到的网站也可能不同。  其他知识点  锚点的内容不会传至服务器上 利用curl命令发送HTTP请求 URL在我理解就是相当于我们现实生活中的定位，我可以通过这个地址找到你或者其他的。   加油&mdash; 后续有相关想法和内容还会一直更新，keep going！ 谢谢观看😄😄😄
    </div>
  </div>
</div>
</div>
      
    </section>

<ul class="pagination">
    
    <li class="page-item">
        <a href="/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
    
        
        
    
    
    <li class="page-item active"><a class="page-link" href="/posts/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/2/">2</a></li>
    
    
    <li class="page-item">
    <a href="/posts/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li class="page-item">
        <a href="/posts/page/2/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://zheng-en.xyz/" >
    &copy; 2020 郑李建的个人博客
  </a>
    <div>










</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
